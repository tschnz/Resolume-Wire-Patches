
/*{
    "CREDIT": "",
    "DESCRIPTION": "",
    "CATEGORIES": [ "generator" ],
    "INPUTS": [
        {
            "TYPE": "image",
            "NAME": "TRAIL_MAP",
            "LABEL": "Trail Map"
        },
        {
            "TYPE": "image",
            "NAME": "AGENT_POS",
            "LABEL": "Agent Position"
        },
        {
            "TYPE": "float",
            "NAME": "SA",
            "LABEL": "Sensor Angle"
        },
        {
            "TYPE": "float",
            "NAME": "SO",
            "LABEL": "Sensor Offset"
        },
        {
            "TYPE": "float",
            "NAME": "RA",
            "LABEL": "Random Angle"
        },
        {
            "TYPE": "float",
            "NAME": "SS",
            "LABEL": "Step Size"
        },
        {
            "TYPE": "bool",
            "NAME": "WRAP",
            "LABEL": "Wrapping"
        },
        {
            "TYPE": "float",
            "NAME": "BORDER",
            "LABEL": "Border"
        }, 
        {
            "TYPE": "float",
            "NAME": "MAP_W",
            "LABEL": "Map Width"
        },
        { 
            "TYPE": "float",
            "NAME": "MAP_H",
            "LABEL": "Map Height"
        }
    ]
}*/

/*
ISF Reference
=-=-=-=-=-=-=

1) Valid inputs:
    - "event"
    - "bool"
    - "long"
    - "float"
    - "point2D"
    - "color"
    - "image"
    - "audio"
    - "audioFFT"

2) Functions:
    - IMG_NORM_PIXEL() -> get a pixel from input with normalized coordinates
    - IMG_PIXEL() -> get a pixel from input with screen space coordinates

3) Predefined variables:
    - RENDERSIZE (resolution of the shader)
    - TIME (run time)
    - gl_FragCoord.xy (screen space coordinates of current fragment)
    - isf_FragNormCoord.xy (normalized coordinates)

To learn more see:
https://github.com/mrRay/ISF_Spec/
*/
const float PI = 3.141592653589793;
const float PI_2 = 6.283185307179586;
const float PI_H = 1.5707963267948966;

float toLuma(vec3 color) {
    return dot(color, vec3(0.2126, 0.7152, 0.0722));
}

float toAvg(vec3 color) {
    return (color.r + color.g + color.b) / 3.0;
}

float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec2 calcPositionRad(vec2 pos, float rad, vec2 dist) {
    vec2 direction = vec2(cos(rad), sin(rad));
    
    vec2 newPos = pos + dist * direction;
    if(WRAP)
        newPos = mod(newPos, 1.0);

    return newPos;
}

vec2 reflectOffBounds(vec2 vec, float minVal, float maxVal) {
    // Clamp the vector to the boundaries
    vec = clamp(vec, vec2(minVal), vec2(maxVal));

    // Calculate the reflection vector based on the normal of the boundary
    vec2 normal = vec2(0.0);
    normal.x = vec.x < minVal ? 1.0 : vec.x > maxVal ? -1.0 : 0.0;
    normal.y = vec.y < minVal ? 1.0 : vec.y > maxVal ? -1.0 : 0.0;
    float dotProduct = dot(vec, normal);
    return vec - 2.0 * dotProduct * normal;
}

vec3 updateAgent(vec2 pos, float dir, vec2 ss) {
    vec2 newPos = calcPositionRad(pos, dir * PI_2, ss);
    float border = BORDER;

    if(WRAP)
        newPos = mod(newPos, 1.0);
    else {
        if(newPos.x < border || newPos.x > 1.0-border || newPos.y < border || newPos.y > 1.0-border)
        {
            vec2 reflection = reflectOffBounds(newPos, border, 1.0 - border);
            newPos = calcPositionRad(reflection, dir * PI_2, ss);
            dir = atan(newPos.y - pos.y, newPos.x - pos.x) / PI_2;
        }
    }

    return vec3(newPos, dir);
}

float getTrailValue(vec2 pos) {
    
    if(pos.x < 0.0 || pos.x > 1.0 || pos.y < 0.0 || pos.y > 1.0)
        return 0.0;

    vec4 color = IMG_NORM_PIXEL(TRAIL_MAP, pos);
    return toAvg(color.rgb);
}

void main() { 
    // SENSOR OFFSET
    vec2 so = vec2(SO / MAP_W, SO / MAP_H); 
    // SENSOR ANGLE
    float sa = SA * PI;
    // RANDOM ANGLE (as phase, between 0 = straight and 0.5 = full left/right turn)
    float ra = RA * 0.5;

    // Get agent position and direction stored in the agentPos image
    vec4 agentVec = IMG_NORM_PIXEL(AGENT_POS, isf_FragNormCoord.xy);
    vec4 agentVecNext = agentVec;
    vec2 agentPos = agentVec.xy;
    float agentDirRad = agentVec.z * PI_2;

    /* Get trail map color for the 3 sensors. One sensor is in front of the agent, 
        the other two are on the left and right side of the agent at an angle SA.
        The offset distance of all sensors to the agent is SO.

        The agent will move in the direction of the sensor with the highest value.
        He does so by randomly choosing a direction between [-RA,0] (right signal stronges) and [0,RA] (left signal strongest).
        If the front sensor is the strongest, the agent will stay in the same direction.
        If the front sensor is the weakest, the agent will randomly turn left or right between [-RA,+RA].
    */

    // left/right to the agent direction
    vec2 sensorF = calcPositionRad(agentPos, agentDirRad, so);
    vec2 sensorL = calcPositionRad(agentPos, agentDirRad + sa, so);
    vec2 sensorR = calcPositionRad(agentPos, agentDirRad - sa, so);
 
    // Get the sensor values
    float sensorFValue = getTrailValue(sensorF);
    float sensorLValue = getTrailValue(sensorL);
    float sensorRValue = getTrailValue(sensorR);
 
    // Decide the agent direction based on the sensor values
    float dir = 0.0;
    // Front sensor is the strongest
    if(sensorFValue > sensorLValue && sensorFValue > sensorRValue) {
        // Stay facing the same direction
        dir = 0.0;
    // Front sensor is the weakest
    } else if(sensorFValue < sensorLValue && sensorFValue < sensorRValue) {
        // Rotate randomly left or rig ht by uniform val ra
        dir = ra  * (rand(agentPos) * 2.0 - 1.0); 
    // Left sensor is the strongest
    } else if(sensorLValue > sensorRValue) {
        // Rotate left by ra
        dir =  ra * rand(agentPos);
    // Right sensor is the strongest
    } else if(sensorRValue > sensorLValue){
        // Rotate right by ra
        dir = -ra * rand(agentPos);
    // All sensors are equal
    } else {
        // Stay facing the same direction
        dir = mod(dir + rand(agentPos) - 0.5, 1.0); 
    }

    // Influence the agents direction based on the new dir
    agentVecNext.xyz = updateAgent(agentPos, agentVec.z + dir, vec2(SS / MAP_W, SS / MAP_H));

    gl_FragColor = agentVecNext;
}